<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Roland PD-14DSX</title>
  </head>
  <body style="margin:0; background:#111; color:#fff; font-family:sans-serif; overflow:hidden;">
    <canvas id="snareCanvas" style="display:block;"></canvas>
    <script>
      const canvas = document.getElementById('snareCanvas');
      const ctx = canvas.getContext('2d');
      let center = { x: 0, y: 0 };
      let maxRadius = 0;
      const barW = 24;
      const barGap = 20;
      const barMargin = 20;

      const state = {
        angleCc: 0,
        radiusCc: 0,
        velocityMsb: 0,
        velocityLsb: 0,
        velocity14: 0,
        lastHit: null,
      };

      // MIDI batch tracking - collects note on + CCs + note off
      const midiBatch = {
        collecting: false,
        noteOn: null,
        ccs: [],
        noteOff: null,
      };
      
      // Last completed batch for display
      let lastBatch = null;
      
      // MIDI log with burst timeout
      let midiLog = [];
      let lastMessageTime = 0;
      const BURST_TIMEOUT_MS = 1000;
      const MAX_LOG_ENTRIES = 8;
      
      // Drum note lookup
      const drumMap = {
        38: 'Snare Head',
        40: 'Snare Rim',
        23: 'Snare Brush',
        37: 'Snare XStick',
        19: 'Snare Head (wires off)',
        18: 'Snare Rim (wires off)',
        16: 'Snare Brush (wires off)',
        17: 'Snare XStick (wires off)',
        20: 'Wires Off',
        21: 'Wires On',
      };
      
      // CC name lookup
      const ccMap = {
        16: 'Radius',
        80: 'Angle',
        88: 'Fine Vel',
      };

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        center = { x: canvas.width / 2, y: canvas.height / 2 };
        const availableWidth = canvas.width - barW - barGap - barMargin * 2;
        maxRadius = Math.min(availableWidth / 2, canvas.height * 0.45);
        drawSnare();
      }

      function drawSnare() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(center.x, center.y, maxRadius, 0, Math.PI * 2);
        ctx.stroke();

        // velocity bar (right side)
        const barH = maxRadius * 2;
        const barX = center.x + maxRadius + barGap;
        const barY = center.y - maxRadius;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barW, barH);
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 127; i++) {
          const t = i / 126;
          const y = barY + barH - (barH * t);
          ctx.beginPath();
          ctx.moveTo(barX, y);
          ctx.lineTo(barX + 6, y);
          ctx.stroke();
        }
        const vNorm = Math.max(0, Math.min(1, state.velocity14 / 16383));
        const fillH = barH * vNorm;
        ctx.fillStyle = 'rgba(255, 80, 80, 0.9)';
        ctx.fillRect(barX, barY + (barH - fillH), barW, fillH);

        if (state.lastHit) {
          const slices = 8;
          const sliceAngle = (Math.PI * 2) / slices;
          const sliceStart = state.lastHit.sliceIndex * sliceAngle - Math.PI / 2 - (sliceAngle / 2);
          const sliceEnd = sliceStart + sliceAngle;

          // highlight slice
          ctx.fillStyle = 'rgba(100, 170, 255, 0.35)';
          ctx.beginPath();
          ctx.moveTo(center.x, center.y);
          ctx.arc(center.x, center.y, maxRadius, sliceStart, sliceEnd);
          ctx.closePath();
          ctx.fill();

          // draw curved stripe at radius
          ctx.strokeStyle = 'rgba(255, 80, 80, 0.9)';
          ctx.lineWidth = 32;
          ctx.beginPath();
          ctx.arc(center.x, center.y, state.lastHit.radius, sliceStart, sliceEnd);
          ctx.stroke();
        }
        
        // Draw MIDI log on the left side
        drawMidiLog();
      }
      
      function addToMidiLog(type, note, value, cssColor) {
        const now = performance.now();
        
        // Clear log if burst timeout exceeded
        if (lastMessageTime > 0 && (now - lastMessageTime) > BURST_TIMEOUT_MS) {
          midiLog = [];
        }
        lastMessageTime = now;
        
        midiLog.push({ type, note, value, color: cssColor });
        
        // Keep only recent entries
        if (midiLog.length > MAX_LOG_ENTRIES) {
          midiLog.shift();
        }
        
        drawSnare();
      }
      
      function drawMidiLog() {
        if (midiLog.length === 0) return;
        
        const fontSize = 18;
        const lineHeight = 24;
        const padding = 20;
        const leftX = padding;
        let y = center.y - maxRadius;
        
        ctx.font = `${fontSize}px monospace`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        
        for (const entry of midiLog) {
          const drumName = drumMap[entry.note] || '';
          const typeStr = entry.type.padEnd(8);
          const noteStr = entry.note !== null ? String(entry.note).padStart(3) : '   ';
          const valStr = entry.value !== null ? String(entry.value).padStart(3) : '   ';
          
          ctx.fillStyle = entry.color;
          ctx.fillText(typeStr, leftX, y);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.fillText(`${noteStr} ${valStr}`, leftX + 90, y);
          ctx.fillStyle = 'rgba(170, 170, 170, 0.7)';
          ctx.fillText(drumName, leftX + 170, y);
          y += lineHeight;
        }
        
        // Computed values below
        y += 12;
        ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
        ctx.font = `${fontSize - 2}px monospace`;
        ctx.fillText(`Vel14: ${state.velocity14}  Angle: ${state.angleCc}  Radius: ${state.radiusCc}`, leftX, y);
      }
      
      function getCcName(cc) {
        return ccMap[cc] || `CC${cc}`;
      }

      function updateHitFromCc() {
        const slices = 8;
        const sliceIndex = Math.max(0, Math.min(slices - 1, Math.floor(state.angleCc / 16)));
        const stripeHalf = 16; // half of lineWidth (32)
        const rawRadius = (state.radiusCc / 127) * maxRadius;
        const radius = Math.max(stripeHalf, Math.min(maxRadius - stripeHalf, rawRadius));
        state.lastHit = { sliceIndex, radius };
        drawSnare();
      }

      function updateHitFromTest() {
        const slices = 8;
        const sliceIndex = Math.max(0, Math.min(slices - 1, Math.floor(state.angleCc / 16)));
        const stripeHalf = 16; // half of lineWidth (32)
        const rawRadius = (state.radiusCc / 127) * maxRadius;
        const radius = Math.max(stripeHalf, Math.min(maxRadius - stripeHalf, rawRadius));
        state.lastHit = { sliceIndex, radius };
        drawSnare();
      }

      window.addEventListener('keydown', (evt) => {
        const key = (evt.key || '').toLowerCase();
        if (key >= '1' && key <= '8') {
          const idx = Number(key) - 1;
          state.angleCc = idx * 16;
          updateHitFromTest();
          evt.preventDefault();
          return;
        }
        if (key === 'c') {
          state.radiusCc = 0;
          state.velocity14 = 16383;
          updateHitFromTest();
          evt.preventDefault();
          return;
        }
        if (key === 'm') {
          state.radiusCc = 64;
          state.velocity14 = 8192;
          updateHitFromTest();
          evt.preventDefault();
          return;
        }
        if (key === 'e') {
          state.radiusCc = 127;
          state.velocity14 = 2048;
          updateHitFromTest();
          evt.preventDefault();
        }
      });

      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function log(msg) {
        console.log(msg);
      }

      function handleInputsAndOutputs(midiAccess) {
        log('MIDI access granted. Listening for messagesâ€¦');

        function onMIDIMessage(event) {
          const data = event.data || [];
          let str = `MIDI @ ${event.timeStamp} [${data.length} bytes]: `;
          for (const b of data) str += `0x${b.toString(16)} `;
          console.log(str);

          if (data.length >= 1) {
            const status = data[0];
            const cmd = status & 0xf0;
            const channel = status & 0x0f;
            const data1 = data[1];
            const data2 = data[2];

            if (cmd === 0x90 && data2 > 0) {
              // Note On - start collecting a new batch
              console.log(`NOTE noteon ch=${channel + 1} note=${data1} vel=${data2}`);
              midiBatch.collecting = true;
              midiBatch.noteOn = { note: data1, velocity: data2, channel: channel + 1 };
              midiBatch.ccs = [];
              midiBatch.noteOff = null;
              
              state.velocityMsb = data2;
              state.velocity14 = (state.velocityMsb << 7) | (state.velocityLsb & 0x7f);
              updateHitFromCc();
              
              addToMidiLog('Note On', data1, data2, 'rgba(100, 255, 100, 0.9)');
            } else if (cmd === 0x90 && data2 === 0 || cmd === 0x80) {
              // Note Off - complete the batch
              console.log(`NOTE noteoff ch=${channel + 1} note=${data1} vel=${data2}`);
              midiBatch.noteOff = { note: data1, velocity: data2, channel: channel + 1 };
              midiBatch.collecting = false;
              
              // Save completed batch for display
              lastBatch = {
                noteOn: midiBatch.noteOn,
                ccs: [...midiBatch.ccs],
                noteOff: midiBatch.noteOff
              };
              
              addToMidiLog('Note Off', data1, data2, 'rgba(255, 100, 100, 0.9)');
            } else if (cmd === 0xb0) {
              // CC message
              console.log(`CC ch${channel + 1}: ${data1} -> ${data2}`);
              if (data1 === 80) state.angleCc = data2;
              if (data1 === 16) state.radiusCc = data2;
              if (data1 === 88) state.velocityLsb = data2;
              
              // Add to current batch if collecting
              if (midiBatch.collecting) {
                midiBatch.ccs.push({ controller: data1, value: data2, channel: channel + 1 });
              }
              
              addToMidiLog(getCcName(data1), data1, data2, 'rgba(100, 170, 255, 0.9)');
            } else {
              console.log(`MIDI cmd=0x${cmd.toString(16)} ch=${channel + 1} raw=[${Array.from(data).join(',')}]`);
            }
          }
        }

        midiAccess.inputs.forEach((entry) => {
          const input = entry[1] || entry;
          if (typeof input.onmidimessage !== 'undefined') {
            input.onmidimessage = onMIDIMessage;
            console.log('Attached onmidimessage to input:', input.id || input.name || input);
          }
        });

        if (typeof midiAccess.onstatechange === 'undefined') {
          midiAccess.onstatechange = (e) => {
            console.log('MIDI device state changed', e);
          };
        }
      }

      async function requestMidiAccess() {
        if (typeof navigator.requestMIDIAccess === 'function') {
          try {
            const access = await navigator.requestMIDIAccess({ sysex: true });
            handleInputsAndOutputs(access);
          } catch (err) {
            log('requestMIDIAccess failed: ' + (err && err.message ? err.message : String(err)));
          }
        } else {
          log('Web MIDI API not available in this browser.');
        }
      }

      async function startMIDI() {
        const hasPermissionsAPI = !!navigator.permissions && typeof navigator.permissions.query === 'function';
        if (hasPermissionsAPI) {
          try {
            const result = await navigator.permissions.query({ name: 'midi', sysex: true });
            if (result.state === 'granted' || result.state === 'prompt') {
              await requestMidiAccess();
            } else {
              log('MIDI access denied.');
            }
            return;
          } catch (err) {
            // Fall back to requestMIDIAccess
          }
        }
        await requestMidiAccess();
      }

      startMIDI();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MIDI Monitor</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #111;
      color: #fff;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 42px;
    }
    h1 {
      margin: 0 0 10px 0;
      font-size: 1.5em;
      color: #888;
    }
    #status {
      margin-bottom: 15px;
      padding: 10px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
    }
    #status .label {
      color: #666;
    }
    #status .value {
      color: #fff;
    }
    #status .connected {
      color: #6f6;
    }
    #status .disconnected {
      color: #f66;
    }
    #log {
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 10px;
      max-height: 80vh;
      overflow-y: auto;
    }
    #log table {
      width: 100%;
      border-collapse: collapse;
    }
    #log th {
      text-align: left;
      color: #666;
      font-weight: normal;
      padding: 4px 24px 8px 0;
      border-bottom: 1px solid #333;
    }
    #log td {
      padding: 3px 24px 3px 0;
      vertical-align: top;
      white-space: nowrap;
    }
    .note-on {
      color: #6f6;
    }
    .note-off {
      color: #f66;
    }
    .cc {
      color: #6af;
    }
    .other {
      color: #fa6;
    }
    .col-type {
      width: 160px;
    }
    .col-note {
      width: 100px;
    }
    .col-name {
      width: 160px;
    }
    .col-value {
      width: 100px;
      text-align: right;
    }
    .col-instrument {
      color: #aaa;
      white-space: nowrap;
    }
    .burst-separator {
      border-top: 1px dashed #333;
    }
    .burst-separator td {
      padding-top: 12px;
    }
    #log tbody tr:nth-child(even) {
      background: #181818;
    }
  </style>
</head>
<body>
  <h1>MIDI Monitor</h1>
  <div id="status">
    <span class="label">Status: </span>
    <span id="connectionStatus" class="disconnected">Connecting...</span>
    <span style="margin-left: 20px;" class="label">Device: </span>
    <span id="deviceName" class="value">-</span>
    <span style="margin-left: 20px;" class="label">Channel: </span>
    <span id="channelDisplay" class="value">-</span>
  </div>
  <div id="log">
    <table>
      <thead>
        <tr>
          <th class="col-type">Type</th>
          <th class="col-note">Note</th>
          <th class="col-name">Name</th>
          <th class="col-value">Value</th>
          <th class="col-instrument">Instrument</th>
        </tr>
      </thead>
      <tbody id="logBody">
      </tbody>
    </table>
  </div>

  <script>
    // Drum note lookup table
    const drumMap = {
      // Snare (normal)
      38: 'Snare Head',
      40: 'Snare Rim',
      23: 'Snare Brush',
      37: 'Snare XStick',
      // Snare (wires off)
      19: 'Snare Head (wires off)',
      18: 'Snare Rim (wires off)',
      16: 'Snare Brush (wires off)',
      17: 'Snare XStick (wires off)',
      // Wire lever
      20: 'Wires Off',
      21: 'Wires On',
    };

    // CC name lookup
    const ccMap = {
      16: 'Radius',
      80: 'Angle',
      88: 'Fine Velocity',
    };

    // Note name conversion
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    function midiNoteToName(note) {
      const octave = Math.floor(note / 12) - 1;
      const name = noteNames[note % 12];
      return `${name}${octave}`;
    }

    // State
    let lastMessageTime = 0;
    const BURST_TIMEOUT_MS = 1000;
    let detectedChannel = null;
    let isNewBurst = true;

    const logBody = document.getElementById('logBody');
    const connectionStatus = document.getElementById('connectionStatus');
    const deviceNameEl = document.getElementById('deviceName');
    const channelDisplay = document.getElementById('channelDisplay');

    function formatRaw(data) {
      return Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
    }

    function addLogEntry(type, channel, note, name, value, instrument, cssClass) {
      const now = performance.now();
      const timeSinceLastMsg = now - lastMessageTime;
      
      // Check for burst timeout - if > 1 second since last message, clear log
      if (lastMessageTime > 0 && timeSinceLastMsg > BURST_TIMEOUT_MS) {
        logBody.innerHTML = '';
        isNewBurst = true;
      }
      
      lastMessageTime = now;

      const tr = document.createElement('tr');
      tr.className = cssClass;
      
      // Add separator styling for new bursts (except first entry)
      if (isNewBurst && logBody.children.length > 0) {
        tr.classList.add('burst-separator');
      }
      isNewBurst = false;

      tr.innerHTML = `
        <td class="col-type">${type}</td>
        <td class="col-note">${note}</td>
        <td class="col-name">${name}</td>
        <td class="col-value">${value}</td>
        <td class="col-instrument">${instrument}</td>
      `;
      
      logBody.appendChild(tr);
      
      // Auto-scroll to bottom
      const logDiv = document.getElementById('log');
      logDiv.scrollTop = logDiv.scrollHeight;

      // Update detected channel display
      if (channel !== '-' && detectedChannel !== channel) {
        detectedChannel = channel;
        channelDisplay.textContent = channel;
      }
    }

    function handleMIDIMessage(event) {
      const data = event.data || [];
      if (data.length < 1) return;

      const status = data[0];
      const cmd = status & 0xf0;
      const channel = (status & 0x0f) + 1;
      const data1 = data[1];
      const data2 = data[2];
      const raw = formatRaw(data);

      if (cmd === 0x90 && data2 > 0) {
        // Note On
        const noteName = midiNoteToName(data1);
        const instrumentName = drumMap[data1] || '';
        addLogEntry('Note On', channel, data1, noteName, data2, instrumentName, 'note-on');
      } else if (cmd === 0x90 && data2 === 0 || cmd === 0x80) {
        // Note Off
        const noteName = midiNoteToName(data1);
        const instrumentName = drumMap[data1] || '';
        addLogEntry('Note Off', channel, data1, noteName, data2, instrumentName, 'note-off');
      } else if (cmd === 0xb0) {
        // CC
        const ccName = ccMap[data1] || `CC ${data1}`;
        addLogEntry('CC', channel, data1, ccName, data2, '', 'cc');
      } else if (cmd === 0xe0) {
        // Pitch Bend
        const bendValue = ((data2 << 7) | data1) - 8192;
        addLogEntry('Pitch Bend', channel, '-', '', bendValue, '', 'other');
      } else if (cmd === 0xc0) {
        // Program Change
        addLogEntry('Program', channel, data1, '', '-', '', 'other');
      } else if (cmd === 0xd0) {
        // Channel Pressure
        addLogEntry('Pressure', channel, '-', '', data1, '', 'other');
      } else if (cmd === 0xa0) {
        // Polyphonic Aftertouch
        const noteName = midiNoteToName(data1);
        addLogEntry('Poly AT', channel, data1, noteName, data2, '', 'other');
      } else if (status === 0xf8) {
        // Timing clock - ignore (too spammy)
      } else if (status === 0xfe) {
        // Active sensing - ignore (too spammy)
      } else {
        // Other/unknown
        addLogEntry('Other', '-', '-', '', '-', '', 'other');
      }
    }

    async function initializeMIDI() {
      try {
        if (!navigator.requestMIDIAccess) {
          connectionStatus.textContent = 'Web MIDI not supported';
          connectionStatus.className = 'disconnected';
          return;
        }

        const midiAccess = await navigator.requestMIDIAccess({ sysex: true });
        const inputs = Array.from(midiAccess.inputs.values());

        if (inputs.length === 0) {
          connectionStatus.textContent = 'No MIDI devices found';
          connectionStatus.className = 'disconnected';
          return;
        }

        // Connect to first input
        const input = inputs[0];
        input.onmidimessage = handleMIDIMessage;

        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'connected';
        deviceNameEl.textContent = input.name || 'Unknown Device';

        console.log('MIDI Monitor connected to:', input.name);

        // Listen for device changes
        midiAccess.onstatechange = (e) => {
          console.log('MIDI device state changed:', e.port.name, e.port.state);
          if (e.port.state === 'disconnected' && e.port.id === input.id) {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'disconnected';
          }
        };

      } catch (error) {
        connectionStatus.textContent = 'MIDI access denied';
        connectionStatus.className = 'disconnected';
        console.error('MIDI error:', error);
      }
    }

    // Start immediately
    initializeMIDI();

    // Simulated MIDI data for testing (spacebar)
    const knownDrumNotes = [38, 40, 23, 37, 19, 18, 16, 17, 20, 21];
    const unknownDrumNotes = [36, 42, 46, 49, 51, 60, 100];
    const knownCCs = [16, 80, 88];
    const unknownCCs = [1, 7, 11, 64, 74];

    function randomChoice(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function randomInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function simulateMidiBurst() {
      const channel = 10; // Drums typically on channel 10
      
      // Pick a note - 70% chance known, 30% unknown
      const note = Math.random() < 0.7 
        ? randomChoice(knownDrumNotes) 
        : randomChoice(unknownDrumNotes);
      
      const velocity = randomInt(40, 127);
      
      // Simulate Note On
      const noteOnData = new Uint8Array([0x90 | (channel - 1), note, velocity]);
      handleMIDIMessage({ data: noteOnData });
      
      // Simulate some CCs (like Roland digital drums send)
      const numCCs = randomInt(1, 3);
      for (let i = 0; i < numCCs; i++) {
        // 60% chance known CC, 40% unknown
        const cc = Math.random() < 0.6 
          ? randomChoice(knownCCs) 
          : randomChoice(unknownCCs);
        const ccValue = randomInt(0, 127);
        const ccData = new Uint8Array([0xB0 | (channel - 1), cc, ccValue]);
        handleMIDIMessage({ data: ccData });
      }
      
      // Simulate Note Off
      const noteOffData = new Uint8Array([0x80 | (channel - 1), note, 0]);
      handleMIDIMessage({ data: noteOffData });
    }

    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        event.preventDefault();
        simulateMidiBurst();
      }
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>MIDI Monitor</title>
    </head>
    <body>
  <h1>MIDI Monitor</h1>
  <label for="patternSelect">Pattern: </label>
  <select id="patternSelect"></select>
  <div id="debug"></div>
  <canvas id="patternCanvas" width="1125" height="300" style="border:1px solid #ddd; display:block; margin-top:6px"></canvas>
        <script>
window._matchOrigin = performance.now();
window._matchBuffer = [];
const MATCH_WINDOW = 3000;
const SCORE_DECAY_MS = 3000; // time constant for exponential weight and pruning
const MAX_MATCH_BEATS = 8; // limit match buffer to most recent beats
const STICKING_MISMATCH_BASE = 50000; // base penalty multiplier for sticking mismatches
const NOTE_AGE_CUTOFF_MS = 3000; // discard notes older than this relative to end
const TOP_CANDIDATES = 10; // number of best candidates to keep
const PROGRESS_PENALTY = 20; // penalty if latest note does not advance to expected pattern beat
const DISQUALIFIED_SCORE = 1e12; // large finite score used when extras/misses occur
const FLAM_OFFSET_MS = 30; // spacing between notes in a flam
const DRAG_OFFSET_MS = 30; // spacing between notes in a drag
const TEST_TIMEOUT = 1000;

function addMatchNoteAt(nowTimeMs, velocity, sticking) {
  const t = nowTimeMs - window._matchOrigin;
  window._matchBuffer.push({ time: t, velocity: Number(velocity || 0), sticking: sticking || '' });
  // prune old notes
  // Use a dynamic match window based on the extended pattern length
  const patternLength = window._extendedPattern[window._extendedPattern.length - 1].time - window._extendedPattern[0].time;
  const cutoff = t - patternLength;
  while (window._matchBuffer.length && window._matchBuffer[0].time < cutoff) {
    window._matchBuffer.shift();
  }
  // Also prune anything older than the scoring decay window
  const decayCutoff = t - SCORE_DECAY_MS;
  while (window._matchBuffer.length && window._matchBuffer[0].time < decayCutoff) {
    window._matchBuffer.shift();
  }
  // Keep only the most recent MAX_MATCH_BEATS events
  while (window._matchBuffer.length > MAX_MATCH_BEATS) {
    window._matchBuffer.shift();
  }
  // debug
  console.log('Match buffer: ' + window._matchBuffer.length + ' events');
  // prepare a normalized copy of the match buffer that starts at time=0
  if (window._matchBuffer.length > 0) {
    const firstTime = window._matchBuffer[0].time;
    const normalized = window._matchBuffer.map((m) => ({ time: m.time - firstTime, velocity: m.velocity, sticking: m.sticking }));
    // call search using the same pattern setup used elsewhere, with normalized times
    try {
      console.log('Calling search with normalized match buffer (' + normalized.length + ' events)');
      searchAcrossPatterns(normalized, 1, 1);
    } catch (err) {
      console.error('Search failed:', err);
    }
  }
}

// Keyboard test input
// Right-hand sticking: E = normal, N = ghost, I = accent
// Left-hand sticking:  S = normal, R = ghost, T = accent
window.addEventListener('keydown', (evt) => {
  const key = (evt.key || '').toLowerCase();
  const now = performance.now();
  if (key === 'e') {
    addMatchNoteAt(now, 64, 'R');
  } else if (key === 'n') {
    addMatchNoteAt(now, 127, 'R');
  } else if (key === 'i') {
    addMatchNoteAt(now, 32, 'R');
  } else if (key === 's') {
    addMatchNoteAt(now, 64, 'L');
  } else if (key === 'r') {
    addMatchNoteAt(now, 32, 'L');
  } else if (key === 't') {
    addMatchNoteAt(now, 127, 'L');
  } else if (key === ' ') {
    // Spacebar: normal hit with no sticking label
    addMatchNoteAt(now, 64, '');
  } else {
    return;
  }
  evt.preventDefault();
});

function handleInputsAndOutputs(midiAccess) {
  console.log("Listing MIDI inputs and outputs:");
  for (const entry of midiAccess.inputs) {
    const input = entry[1];
    console.log(
      `Input port [type:'${input.type}']` +
        ` id:'${input.id}'` +
        ` manufacturer:'${input.manufacturer}'` +
        ` name:'${input.name}'` +
        ` version:'${input.version}'`,
    );
  }

  for (const entry of midiAccess.outputs) {
    const output = entry[1];
    console.log(
      `Output port [type:'${output.type}'] id:'${output.id}' manufacturer:'${output.manufacturer}' name:'${output.name}' version:'${output.version}'`,
    );
  }

  function onMIDIMessage(event) {
    let str = `MIDI message received at timestamp ${event.timeStamp}[${event.data.length} bytes]: `;
    for (const character of event.data) {
      str += `0x${character.toString(16)} `;
    }
    console.log(str);

    // Parse and console.log human-friendly info for common MIDI messages
    try {
      const data = event.data;
      if (data && data.length >= 1) {
        const status = data[0];
        const cmd = status & 0xf0;
        const channel = status & 0x0f;
        let type = 'unknown';
        if (cmd === 0x80) type = 'noteoff';
        else if (cmd === 0x90) type = 'noteon';
        else if (cmd === 0xa0) type = 'poly aftertouch';
        else if (cmd === 0xb0) type = 'controlchange';
        else if (cmd === 0xc0) type = 'programchange';
        else if (cmd === 0xd0) type = 'channel aftertouch';
        else if (cmd === 0xe0) type = 'pitchbend';

        function noteName(n) {
          const names = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
          return names[n % 12] + Math.floor(n / 12) - 1;
        }

        if (type === 'noteon' || type === 'noteoff') {
          const note = data[1];
          const velocity = data[2];
          console.log(`MIDI parsed: ${type} ch=${channel+1} note=${note} (${noteName(note)}) velocity=${velocity}`);
        } else if (type === 'controlchange') {
          console.log(`MIDI parsed: controlchange ch=${channel+1} controller=${data[1]} value=${data[2]}`);
        } else if (type === 'programchange') {
          console.log(`MIDI parsed: programchange ch=${channel+1} program=${data[1]}`);
        } else {
          // generic dump for other messages
          console.log(`MIDI parsed: cmd=0x${cmd.toString(16)} ch=${channel+1} raw=[${Array.from(data).join(',')}]`);
        }
      }
    } catch (e) {
      console.error('Error parsing MIDI message', e);
    }

    // Parse Note On messages and add to the running match buffer.
    try {
      const data = event.data;
      if (data && data.length >= 3) {
        const status = data[0];
        const data1 = data[1];
        const data2 = data[2];
        const cmd = status & 0xf0;
        // 0x90 = Note On; treat velocity 0 as Note Off
        if (cmd === 0x90 && data2 > 0) {
          // Use performance.now() for timing accuracy
          addMatchNoteAt(performance.now(), data2);
        }
      }
    } catch (e) {
      console.error('Failed to parse MIDI message', e);
    }
  }

  function startLoggingMIDIInput(midiAccess) {
    // midiAccess.inputs is an iterable of [id, input] entries
    midiAccess.inputs.forEach((entry) => {
      const input = entry[1] || entry;
      if (typeof input.onmidimessage !== 'undefined') {
        input.onmidimessage = onMIDIMessage;
        console.log('Attached onmidimessage to input:', input.id || input.name || input);
      }
    });

    // Also listen for device connect/disconnect events
    if (typeof midiAccess.onstatechange === 'undefined') {
      midiAccess.onstatechange = (e) => {
        console.log('MIDI device state changed', e);
      };
    }
  }

  // Attach handlers for current inputs immediately
  startLoggingMIDIInput(midiAccess);
}

async function requestMidiAccess()
{
  console.log("Requesting MIDI access...");
  if (typeof navigator.requestMIDIAccess === "function") {
    try {
      const access = await navigator.requestMIDIAccess({ sysex: true });
      console.log("navigator.requestMIDIAccess succeeded.");
      // You could inspect access.inputs/outputs here if needed.
      handleInputsAndOutputs(access);
    } catch (err) {
      console.log("requestMIDIAccess failed: " + (err && err.message ? err.message : String(err)));
    }
  } else {
    console.log("Web MIDI API (navigator.requestMIDIAccess) is not available in this browser.");
  }
}

// Use an async IIFE so we can await feature checks and API calls.
async function startMIDI() {
  // If Permissions API or its query method isn't present, fall back.
  const hasPermissionsAPI = !!navigator.permissions && typeof navigator.permissions.query === "function";

  if (hasPermissionsAPI) {
    try {
      // Some browsers (notably some WebKit builds) will reject or throw when
      // asked about non-supported permission names (like 'midi' with sysex).
      const result = await navigator.permissions.query({ name: "midi", sysex: true });
      console.log("Permissions.query succeeded.");
      if (result.state === "granted") {
        console.log("MIDI access granted.");
        await requestMidiAccess();
      } else if (result.state === "prompt") {
        console.log("MIDI access will prompt for permission.");
        await requestMidiAccess();
      } else {
        console.log("MIDI access denied.");
      }
      return;
    } catch (err) {
      // Catch NotSupportedError and other failures from Permissions.query.
      console.log("Permissions.query failed: " + (err && err.message ? err.message : String(err)));
      // Fall through to try requestMIDIAccess as a fallback.
    }
  } else {
    console.log("Permissions API/query not available in this browser.");
  }
}

var diddle0 = [
  // { time:    0, velocity: 170, sticking: 'R' },
  { time:    0, velocity: 100, sticking: 'L' },
  { time:  100, velocity: 100, sticking: 'R' },
  { time:  200, velocity: 100, sticking: 'R' },
  { time:  300, velocity: 170, sticking: 'L' }
]

diddle1 = [
  {"time":0,"velocity":23,"sticking":""},
  {"time":186.69999998807907,"velocity":45,"sticking":""}]

diddle2 = [
  {"time":0,"velocity":127,"sticking":""},
  {"time":267.30000001192093,"velocity":32.49999999999999,"sticking":""},
  {"time":516.1000000238419,"velocity":32.49999999999999,"sticking":""}]

diddle3 = [
  {"time":0,"velocity":40.66666666666667,"sticking":""},
  {"time":224.39999997615814,"velocity":33.66666666666667,"sticking":""},
  {"time":486.19999998807907,"velocity":127,"sticking":""},
  {"time":770,"velocity":54.66666666666667,"sticking":""}] 

diddle4 = [
  {"time":0,"velocity":43.53503184713376,"sticking":""},
  {"time":283.19999998807907,"velocity":127,"sticking":""},
  {"time":583,"velocity":51.560509554140125,"sticking":""},
  {"time":812.5,"velocity":33.904458598726116,"sticking":""}]

function score(pattern, match, velocityWeight, stickingWeight) {
  function square(x) { return x * x; }
  var dynamics = 0; // velocity matching
  var timing = 0; // timing + penalties
  var reuseCount = 0;
  var gapCount = 0;
  var stickingCount = 0;
  var c = 0;
  var alreadyMatched = [];
  var start = pattern[0].time; // pattern start
  var end = match[match.length - 1].time;
  // Discard match notes older than the decay window relative to the last note
  var recentCutoff = end - SCORE_DECAY_MS;
  var filtered = match.filter((m) => m.time >= recentCutoff);
    if (!filtered.length) return { dynamics: Number.MAX_VALUE, timing: Number.MAX_VALUE, reuseCount: reuseCount, gapCount: gapCount, stickingCount: stickingCount };
  match = filtered;
  for (var i = 0; i < match.length; i++) {
    var m = match[i];
    if (end - m.time > NOTE_AGE_CUTOFF_MS) {
      break;
    }
    var d = Number.MAX_VALUE;
    var pj = -1;
    var timeTerm = 0;
    var velTerm = 0;
    var stickPenalty = 0;
    var bestStickMismatch = 0;
    for (var j = 0; j < pattern.length; j++) {
      var pp = pattern[j];
      var dd = square(pp.time - m.time);
      if (dd < d) {
        const stickingMismatch = (m.sticking === '' || pp.sticking == m.sticking) ? 0 : 1;
        stickPenalty = stickingMismatch ? (stickingWeight * STICKING_MISMATCH_BASE) : 0;
        timeTerm = dd;
        velTerm = square(pp.velocity - m.velocity) * velocityWeight;
        d = dd + velTerm + stickPenalty;
        pj = j;
        bestStickMismatch = stickingMismatch;
      }
    }
    if (pj >= 0 && alreadyMatched[pj]) {
      // Track reuse of the same pattern beat (extra hits)
      reuseCount++;
    }
    if (pj >= 0) {
      alreadyMatched[pj] = true;
      stickingCount += bestStickMismatch;
    }
    // Weight by exponential growth: notes closer to pattern start have near-zero weight,
    // notes toward the end have higher weight. Uses (1 - exp(-t)) to approach 1 asymptotically
    var timeFromStart = m.time - start;
    var weight = 1 - Math.exp(-timeFromStart / SCORE_DECAY_MS); // approaches 1 as time increases
    timing += (timeTerm + stickPenalty) * weight;
    dynamics += velTerm * weight;
    c++;
  }
  // Penalize gaps: pattern beats between the first and last matched beat that remain unmatched
  var firstIdx = -1;
  var lastIdx = -1;
  for (var k = 0; k < pattern.length; k++) {
    if (alreadyMatched[k]) {
      if (firstIdx === -1) firstIdx = k;
      lastIdx = k;
    }
  }
  if (firstIdx !== -1 && lastIdx > firstIdx) {
    var gapUnmatched = 0;
    for (var k2 = firstIdx; k2 <= lastIdx; k2++) {
      if (!alreadyMatched[k2]) gapUnmatched++;
    }
    if (gapUnmatched > 0) {
      // Track unmatched beats within the matched window (misses)
      gapCount += gapUnmatched;
    }
  }
  if (c === 0) return { dynamics: Number.MAX_VALUE, timing: Number.MAX_VALUE, reuseCount: reuseCount, gapCount: gapCount, stickingCount: stickingCount };

  var norm = c;
  var baseDynamics = Math.sqrt(dynamics / norm);
  var baseTiming = Math.sqrt(timing / norm);

  if (reuseCount > 0 || gapCount > 0) {
    // Drastically inflate timing so penalized candidates sort last
    const penalty = DISQUALIFIED_SCORE + (reuseCount + gapCount) * 1e10;
    return {
      dynamics: baseDynamics,
      timing: baseTiming + penalty,
      reuseCount: reuseCount,
      gapCount: gapCount,
      stickingCount: stickingCount
    };
  }

  return {
    dynamics: baseDynamics,
    timing: baseTiming,
    reuseCount: reuseCount,
    gapCount: gapCount,
    stickingCount: stickingCount
  };
}

function scaleTime(pattern, factor) { // assumes 0 origin time
  var scaled = [];
  for (var i = 0; i < pattern.length; i++) {
    var p = pattern[i];
    scaled.push({
      time: p.time * factor,
      velocity: p.velocity,
      sticking: p.sticking
    });
  }
  return scaled;
}

function scaleVelocity(pattern, factor, vmin = 32, vmax = 127) {
  var scaled = [];
  for (var i = 0; i < pattern.length; i++) {
    var p = pattern[i];
    var v = Number(p.velocity || 0) * factor;
    v = Math.max(vmin, Math.min(vmax, v));
    scaled.push({
      time: p.time,
      velocity: v,
      sticking: p.sticking
    });
  }
  return scaled;
}

function toNumericVelocity(v) {
  if (typeof v === 'number') return v;
  const up = String(v || '').toUpperCase();
  if (up === 'A') return 127;
  if (up === 'G') return 32;
  // treat N, space, empty, undefined as normal
  return 64;
}

// Parse a tiny DSL for patterns: A/a=accent (R/L), G/g=ghost (R/L), N/n=normal (R/L), F/f=flam (two quick normals, sticking from case), D/d=double (two normals evenly spaced in one beat), .=rest.
// Case encodes sticking: uppercase = R, lowercase = L. Returns an array of { time, velocity, sticking } spaced beatMs apart (default 200ms).
function parsePatternDSL(dsl, beatMs = 200, opts = {}) {
  if (!dsl || typeof dsl !== 'string') return [];
  const { repeat = false } = opts || {};
  const events = [];
  let t = 0;
  let hitCount = 0;
  const chars = Array.from(dsl);
  for (let i = 0; i < chars.length; i++) {
    const ch = chars[i];
    if (ch === '.') {
      t += beatMs;
      continue;
    }
    const up = ch.toUpperCase();
    const sticking = ch === up ? 'R' : 'L';

    if (up === 'F') {
      // Flam: two quick normal notes within one beat (sticking from case)
      events.push({ time: t, velocity: 'N', sticking });
      events.push({ time: t + FLAM_OFFSET_MS, velocity: 'N', sticking });
      t += beatMs;
      hitCount += 2;
      continue;
    }
    if (up === 'D') {
      // Double: two evenly spaced normal notes, taking two beats
      events.push({ time: t, velocity: 'N', sticking });
      events.push({ time: t + beatMs, velocity: 'N', sticking });
      t += beatMs * 2;
      hitCount += 2;
      continue;
    }
    if (up === 'R') {
      // Drag: two evenly spaced ghost notes and a normal note within one beat
      events.push({ time: t, velocity: 'G', sticking });
      events.push({ time: t + FLAM_OFFSET_MS, velocity: 'G', sticking });
      events.push({ time: t + FLAM_OFFSET_MS * 2, velocity: 'N', sticking });
      t += beatMs;
      hitCount += 2;
      continue;
    }
    if (up === 'A' || up === 'G' || up === 'N') {
      events.push({ time: t, velocity: up, sticking });
      t += beatMs;
      hitCount += 1;
    }
  }

  if (!repeat || events.length === 0 || t <= 0 || hitCount <= 0) return events;

  const minHits = MAX_MATCH_BEATS * 2;
  const repeats = Math.max(2, Math.ceil(minHits / hitCount));
  const extended = [];
  for (let r = 0; r < repeats; r++) {
    const offset = r * t;
    for (let i = 0; i < events.length; i++) {
      const e = events[i];
      extended.push({ time: e.time + offset, velocity: e.velocity, sticking: e.sticking });
    }
  }
  return extended;
}

const PATTERN_LIBRARY = {
  "Single Stroke Roll": parsePatternDSL('Nn', 200, { repeat: true }),
  "Double Stroke Roll": parsePatternDSL('Dd', 200, { repeat: true }),
  "Five Stroke Roll": parsePatternDSL('DdA...', 200, { repeat: true }),
  "Single Paradiddle": parsePatternDSL('AnDaNd', 200, { repeat: true }),
  "Double Paradiddle": parsePatternDSL('AnNnDaNnNd', 200, { repeat: true }),
  "Triple Paradiddle": parsePatternDSL('AnNnNnDaNnNnNd', 200, { repeat: true }),
  "Flam": parsePatternDSL('Ff', 200, { repeat: true }),
  "Drag": parsePatternDSL('Rr', 200, { repeat: true }),
  "Flam Tap": parsePatternDSL('Fg.fG.', 200, { repeat: true }),
};

const DEFAULT_PATTERN_KEY = 'paradiddle';

function setPattern(name, renderPatternOnly = true) {
  const pat = PATTERN_LIBRARY[name] || PATTERN_LIBRARY[DEFAULT_PATTERN_KEY];
  window._extendedPattern = pat;
  window._lastMatchedPatternIdx = null;

  const select = document.getElementById('patternSelect');
  if (select && select.value !== name && PATTERN_LIBRARY[name]) {
    select.value = name;
  }

  if (renderPatternOnly) {
    renderPatternMatch(window._extendedPattern, [], 1, 0);
  }
}

function populatePatternMenu() {
  const select = document.getElementById('patternSelect');
  if (!select) return;
  select.innerHTML = '';
  Object.keys(PATTERN_LIBRARY).forEach((key) => {
    const opt = document.createElement('option');
    opt.value = key;
    opt.textContent = key;
    select.appendChild(opt);
  });
  select.value = DEFAULT_PATTERN_KEY;
  select.addEventListener('change', (evt) => {
    const name = evt.target.value;
    setPattern(name, true);
    if (window._matchBuffer && window._matchBuffer.length > 0) {
      const firstTime = window._matchBuffer[0].time;
      const normalized = window._matchBuffer.map((m) => ({ time: m.time - firstTime, velocity: m.velocity, sticking: m.sticking }));
      // Run search only against the selected pattern so the user choice is respected
      search(window._extendedPattern, normalized, 1, 1, { render: true, patternName: name });
    }
  });
}

function trimMatchAfterLargeGap(match) {
  if (!match || match.length < 3) return match;
  const gaps = [];
  for (let i = 0; i < match.length - 1; i++) {
    const gap = match[i + 1].time - match[i].time;
    if (gap > 0) gaps.push(gap);
  }
  if (gaps.length < 2) return match;
  const mean = gaps.reduce((s, g) => s + g, 0) / gaps.length;
  const variance = gaps.reduce((s, g) => s + Math.pow(g - mean, 2), 0) / gaps.length;
  const sd = Math.sqrt(variance);
  const threshold = mean + 2 * sd; // heuristic: keep if gap is within two std devs
  for (let i = 0; i < match.length - 1; i++) {
    const gap = match[i + 1].time - match[i].time;
    if (gap > threshold) {
      return match.slice(i + 1); // drop everything before the large gap
    }
  }
  return match;
}

function translateTime(pattern, offset) {
  var translated = [];
  for (var i = 0; i < pattern.length; i++) {
    var p = pattern[i];
    translated.push({
      time: p.time + offset,
      velocity: p.velocity,
      sticking: p.sticking
    });
  }
  return translated;
}

// Render a pattern (background) and a match (overlay) on the canvas.
// pattern: array of {time, velocity, ...}
// match: array of {time, velocity, ...}
// scale: multiplicative time scale applied to match
// translate: time offset (ms) applied to match after scaling
function renderPatternMatch(pattern, match, scale, translate) {
  const canvas = document.getElementById('patternCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const W = canvas.width;
  const H = canvas.height;
  const barWidth = 6;
  const halfBar = barWidth / 2;
  ctx.clearRect(0, 0, W, H);

  if (!pattern || !pattern.length) return;
  
  console.log('renderPatternMatch: ' + pattern.length + ' pattern notes, ' + (match ? match.length : 0) + ' match notes');

  const padding = 10;
  // Render the full extended pattern
  let renderPattern = pattern;

  const patTimes = renderPattern.map((p) => Number(p.time));
  const matchTimes = (match || []).map((m) => Number(m.time));
  const allTimes = patTimes.concat(matchTimes.length ? matchTimes : [patTimes[0], patTimes[patTimes.length - 1]]);
  let minTime = Math.min.apply(null, allTimes);
  let maxTime = Math.max.apply(null, allTimes);
  const timeRange = Math.max(1, maxTime - minTime);

  const leftPad = padding + halfBar;
  const rightPad = padding + halfBar;
  const usableWidth = Math.max(1, W - leftPad - rightPad);
  const mapX = (t) => leftPad + ((t - minTime) / timeRange) * usableWidth;

  // Layout vertically into two bands (pattern top, match bottom).
  const available = H - padding * 2;
  const bandHeight = available / 2;
  const patternBaseline = padding + bandHeight; // bottom of top band
  // Reserve a small label area under the match band so labels can be drawn
  // below the match bars without overlapping the canvas edge.
  const labelHeight = 14; // px (approx for 12px font)
  const labelMargin = 6; // px gap between bar and label
  const matchBaseline = padding + bandHeight * 2 - (labelHeight + labelMargin); // lifted so labels fit below

  // velocity -> bar height using fixed MIDI scale (0..127), not relative to observed max
  const velToHeight = (v) => {
    const norm = Math.max(0, Math.min(127, toNumericVelocity(v))) / 127;
    return norm * (bandHeight * 0.8); // leave a small margin inside each band
  };

  // Draw pattern bars (background) on the top band
  ctx.textAlign = 'center';
  ctx.font = '12px sans-serif';
  const highlightIdx = (typeof window._lastMatchedPatternIdx === 'number') ? window._lastMatchedPatternIdx : -1;
  // Render all sticking labels across the extended pattern
  for (let i = 0; i < renderPattern.length; i++) {
    const p = renderPattern[i];
    const x = mapX(p.time);
    const h = velToHeight(p.velocity);
    // gray bar for pattern (ensure it stays in the top band)
    ctx.fillStyle = (i === highlightIdx) ? '#ff4d4d' : '#cccccc';
    ctx.fillRect(x - halfBar, patternBaseline - h, barWidth, h);
    // sticking label aligned to the top of the top band
    if (p.sticking) {
      ctx.fillStyle = '#222';
      ctx.textBaseline = 'top';
      const labelY = padding + 2;
      ctx.fillText(String(p.sticking), x, labelY);
    }
  }

  // Draw match (already scaled + translated by search) on the bottom band
  if (match && match.length) {
    for (let i = 0; i < match.length; i++) {
      const m = match[i];
      const x = mapX(m.time);
      const h = velToHeight(m.velocity);
      // blue bar for match (ensure it stays in the bottom band)
      ctx.fillStyle = 'rgba(30,144,255,0.85)'; // dodgerblue
      ctx.fillRect(x - halfBar, matchBaseline - h, barWidth, h);
      // sticking label for match (draw all labels)
      if (m.sticking) {
        // Draw the sticking label in blue and below the match bar.
        ctx.fillStyle = '#1e90ff'; // dodgerblue
        ctx.textBaseline = 'top';
        const labelY = matchBaseline + 6; // a small offset below the bar bottom
        ctx.fillText(String(m.sticking), x, labelY);
      }
    }

    // Draw a faint line connecting match and pattern center to indicate offset/scale
    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.moveTo(leftPad, H / 2);
    ctx.lineTo(W - rightPad, H / 2);
    ctx.stroke();
  }

  // (legend removed to keep the canvas area clean)
}

// Keep last render parameters (used to re-render after search without re-running it)
window._lastRender = null;
// Track last matched pattern index for progress heuristic
window._lastMatchedPatternIdx = null;

function oldsearch(pattern, match, velocityWeight, stickingWeight) {
  if (!match || !match.length) return;
  // Compute velocity stats from the incoming match
  const velocities = match.map((m) => Number(m.velocity || 0));
  const vMin = Math.min.apply(null, velocities);
  const vMax = Math.max.apply(null, velocities);
  const vMean = velocities.reduce((sum, v) => sum + v, 0) / velocities.length;
  const span = Math.max(1e-3, Math.max(vMax - vMean, vMean - vMin));
  const targetGhost = 32;
  const targetNormal = 64;
  const targetAccent = 127;
  // Normalize velocities toward ghost/normal/accent anchors, but keep tiny ranges near normal.
  const normalizedMatch = match.map((m) => {
    const v = Number(m.velocity || 0);
    const z = (v - vMean) / span; // roughly -1..1 when data spans both sides of mean
    const mapped = targetNormal + z * (targetAccent - targetNormal);
    const clamped = Math.max(targetGhost, Math.min(targetAccent, mapped));
    return { ...m, velocity: clamped };
  });

  // Use the pattern exactly as provided by the caller. Do not extend here to
  // avoid duplicating repetitions when the caller already passed an extended pattern.
  var pat = pattern.map((p) => ({ time: p.time, velocity: toNumericVelocity(p.velocity), sticking: p.sticking }));

  console.log('Searching (normalized): ' + JSON.stringify(normalizedMatch));
  
  // Filter match to only include notes within the pattern's time range
  var patMinTime = pat[0].time;
  var patMaxTime = pat[pat.length - 1].time;
  var filteredMatch = normalizedMatch.filter((m) => m.time >= patMinTime && m.time <= patMaxTime);

  if (filteredMatch.length === 0) {
    return
  }
  
  var best = Number.MAX_VALUE;
  var bestScale = 1.0;
  var bestTranslate = 0;
  
  for (var st = 0.5; st <= 2.0; st += 0.1) {
    for (var tt = 0; tt <= MATCH_WINDOW * 2; tt += 10 * st) {
      var scaledTime = scaleTime(filteredMatch, st);
      var translatedTime = translateTime(scaledTime, tt);
      var s = score(pat, translatedTime, velocityWeight, stickingWeight);
      var combined = Math.sqrt(s.dynamics * s.dynamics + s.timing * s.timing);
      //console.log("Score: " + combined + " scale: " + st + " translate: " + tt + " (" + combined + ")");
      if (combined < best) {
        best = combined;
        bestScale = st;
        bestTranslate = tt;
        console.log("Best score: " + best + " scale: " + st + " translate: " + tt + " (" + combined + ")");
      }
    }
  }
  // After searching, record the result and render the pattern and the best-matching transformed match on the canvas
  try {
    // Transform the match using the best scale/translate found
    const scaledMatch = scaleTime(normalizedMatch, bestScale);
    const transformedMatch = translateTime(scaledMatch, bestTranslate);
    console.log('Best match found: scale=' + bestScale + ', translate=' + bestTranslate);
    console.log('  Transformed match times: ' + transformedMatch.map((m) => m.time.toFixed(0)).join(', '));
    // store last render state for interactive resizing
    window._lastRender = { pat: pat, match: transformedMatch, scale: bestScale, translate: bestTranslate };
    // Pass the already-transformed match to render (no scale/translate parameters needed)
    renderPatternMatch(pat, transformedMatch, 1.0, 0);
  } catch (e) {
    console.log('Rendering failed: ' + (e && e.message ? e.message : String(e)));
  }
}

function search(pattern, match, velocityWeight, stickingWeight, opts = {}) {
  const { render = true, patternName = null } = opts;
  if (!match || !match.length) return;
  const trimmed = trimMatchAfterLargeGap(match);
  if (!trimmed || !trimmed.length) return;

  // Use raw match velocities; only convert pattern velocities to numeric
  const pat = pattern.map((p) => ({ time: p.time, velocity: toNumericVelocity(p.velocity), sticking: p.sticking }));
  const workMatch = trimmed;
  const t0 = performance.now();

  const candidates = [];
  const denomEps = 1e-6;
  const topN = TOP_CANDIDATES;

  function mapLatestMatchToPattern(transformedMatch, patArr) {
    if (!transformedMatch.length) return -1;
    const last = transformedMatch[transformedMatch.length - 1];
    let bestIdx = -1;
    let bestDist = Number.MAX_VALUE;
    for (let i = 0; i < patArr.length; i++) {
      const dist = Math.abs(patArr[i].time - last.time);
      if (dist < bestDist) {
        bestDist = dist;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  for (let pi = 0; pi < pat.length; pi++) {
    const p0 = pat[pi];
    const p1 = pat[pi + 1];
    if (!p1) continue; // require a next beat
    for (let mi = 0; mi < workMatch.length; mi++) {
      const m0 = workMatch[mi];
      const m1 = workMatch[mi + 1];
      if (!m1) continue; // require a next beat

      const denom = (m1.time - m0.time);
      if (Math.abs(denom) < denomEps) continue;

      const scale = (p1.time - p0.time) / denom;
      if (!isFinite(scale) || scale <= 0) continue;

      const translate = p0.time - m0.time * scale;
      if (translate < 0) continue; // do not explore negative translations
      const scaledTimeMatch = scaleTime(workMatch, scale);
      const mv0 = Number(m0.velocity || 0);
      const pv0 = Number(p0.velocity || 0);
      const vscale = mv0 > 0 ? (pv0 / mv0) : 1;
      if (!isFinite(vscale) || vscale <= 0) continue;
      const timeTranslated = translateTime(scaledTimeMatch, translate);
      const scaledVelMatch = scaleVelocity(timeTranslated, vscale);
      const sc = score(pat, scaledVelMatch, velocityWeight, stickingWeight);
      if (Number.isFinite(sc.dynamics) && Number.isFinite(sc.timing) && sc.dynamics !== Number.MAX_VALUE && sc.timing !== Number.MAX_VALUE) {
        const combined = Math.sqrt(sc.dynamics * sc.dynamics + sc.timing * sc.timing);
        let finalScore = combined;
        const latestIdx = mapLatestMatchToPattern(timeTranslated, pat);
        if (window._lastMatchedPatternIdx !== null && latestIdx >= 0) {
          const expected = window._lastMatchedPatternIdx + 1;
          if (latestIdx !== expected) {
            finalScore += PROGRESS_PENALTY;
          }
        }
        candidates.push({ score: finalScore, dynamics: sc.dynamics, timing: sc.timing, reuseCount: sc.reuseCount, gapCount: sc.gapCount, stickingCount: sc.stickingCount, latestIdx, scale, translate, vscale, match: scaledVelMatch });
      }
    }
  }

  if (!candidates.length) {
    if (render) {
      console.log('search: no candidates, took ' + (performance.now() - t0).toFixed(2) + ' ms');
      const dbg = document.getElementById('debug');
      if (dbg) dbg.textContent = 'No candidates (search ' + (performance.now() - t0).toFixed(2) + ' ms)';
    }
    return null;
  }

  candidates.sort((a, b) => a.score - b.score);
  const top = candidates.slice(0, topN);

  // Store for later refinement
  window._lastCandidates = top;

  const best = top[0];
  best.patternName = patternName;
  if (!render) {
    return best;
  }
  try {
    console.log('Best match found: scale=' + best.scale + ', translate=' + best.translate + (best.vscale ? (', vscale=' + best.vscale) : '') + '; search took ' + (performance.now() - t0).toFixed(2) + ' ms' + (patternName ? (' | pattern=' + patternName) : ''));
    console.log('  Component scores -> dynamics: ' + best.dynamics.toFixed(2) + ', timing: ' + best.timing.toFixed(2));
    console.log('  Counts -> extra beats: ' + (best.reuseCount || 0) + ', missed beats: ' + (best.gapCount || 0) + ', sticking: ' + (best.stickingCount || 0));
    console.log('  Transformed match times: ' + best.match.map((m) => m.time.toFixed(0)).join(', '));
    window._lastRender = { pat: pat, match: best.match, scale: best.scale, translate: best.translate, vscale: best.vscale };
    if (best.latestIdx !== undefined && best.latestIdx >= 0) {
      window._lastMatchedPatternIdx = best.latestIdx;
    }
    renderPatternMatch(pat, best.match, 1.0, 0);
    const dbg = document.getElementById('debug');
    if (dbg) {
      dbg.textContent = 'Dynamics: ' + best.dynamics.toFixed(2) + ' | Timing: ' + best.timing.toFixed(2) + ' | Combined: ' + best.score.toFixed(2) + ' | Extra: ' + (best.reuseCount || 0) + ' | Missed: ' + (best.gapCount || 0) + ' | Sticking: ' + (best.stickingCount || 0) + ' | Scale: ' + best.scale.toFixed(3) + ' | Translate: ' + best.translate.toFixed(1) + (best.vscale ? (' | Vscale: ' + best.vscale.toFixed(3)) : '') + (patternName ? (' | Pattern: ' + patternName) : '');
    }
  } catch (e) {
    console.log('Rendering failed: ' + (e && e.message ? e.message : String(e)));
  }
  return best;
}

// Search all patterns in the library and auto-select the best-scoring pattern.
function searchAcrossPatterns(match, velocityWeight, stickingWeight) {
  if (!match || !match.length) return;
  let bestOverall = null;
  let bestPatternName = null;

  for (const [name, pat] of Object.entries(PATTERN_LIBRARY)) {
    const result = search(pat, match, velocityWeight, stickingWeight, { render: false, patternName: name });
    if (result && (bestOverall === null || result.score < bestOverall.score)) {
      bestOverall = result;
      bestPatternName = name;
    }
  }

  if (!bestOverall || !bestPatternName) return;

  // Switch to the winning pattern (render pattern only)
  setPattern(bestPatternName, true);

  // Render and log using the winning pattern; re-run search for side effects/state updates
  search(PATTERN_LIBRARY[bestPatternName], match, velocityWeight, stickingWeight, { render: true, patternName: bestPatternName });
}

populatePatternMenu();
setPattern(DEFAULT_PATTERN_KEY);
searchAcrossPatterns(diddle4, 1, 1);
//startMIDI();
/*
window.setTimeout(() =>
{
  // alert("diddle0");
  search(window._extendedPattern, diddle0, 1, 1);
  window.setTimeout(() =>
  {
    //alert("diddle1");
    search(window._extendedPattern, diddle1, 1, 1);
    window.setTimeout(() =>
    {
      //alert("diddle2");
      search(window._extendedPattern, diddle2, 1, 1);
      window.setTimeout(() =>
      {
        //alert("diddle3");
        search(window._extendedPattern, diddle3, 1, 1);
        window.setTimeout(() =>
        {
          //alert("diddle4");
          search(window._extendedPattern, diddle4, 1, 1);
          window.setTimeout(startMIDI, TEST_TIMEOUT);
        }, TEST_TIMEOUT);
      }, TEST_TIMEOUT);
    }, TEST_TIMEOUT);
  }, TEST_TIMEOUT);
}, TEST_TIMEOUT);
// */
        </script>
    </body>
</html>
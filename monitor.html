<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MIDI Monitor</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #111;
      color: #fff;
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 14px;
    }
    h1 {
      margin: 0 0 10px 0;
      font-size: 1.5em;
      color: #888;
    }
    #status {
      margin-bottom: 15px;
      padding: 10px;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
    }
    #status .label {
      color: #666;
    }
    #status .value {
      color: #fff;
    }
    #status .connected {
      color: #6f6;
    }
    #status .disconnected {
      color: #f66;
    }
    #log {
      background: #0a0a0a;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 10px;
      max-height: 80vh;
      overflow-y: auto;
    }
    #log table {
      width: 100%;
      border-collapse: collapse;
    }
    #log th {
      text-align: left;
      color: #666;
      font-weight: normal;
      padding: 4px 12px 8px 0;
      border-bottom: 1px solid #333;
    }
    #log td {
      padding: 3px 12px 3px 0;
      vertical-align: top;
    }
    .note-on {
      color: #6f6;
    }
    .note-off {
      color: #f66;
    }
    .cc {
      color: #6af;
    }
    .other {
      color: #fa6;
    }
    .col-type {
      width: 80px;
    }
    .col-channel {
      width: 50px;
      text-align: right;
    }
    .col-note {
      width: 80px;
    }
    .col-name {
      width: 120px;
    }
    .col-value {
      width: 60px;
      text-align: right;
    }
    .col-drum {
      width: 150px;
      color: #aaa;
    }
    .col-raw {
      color: #555;
      font-size: 12px;
    }
    .burst-separator {
      border-top: 1px dashed #333;
    }
    .burst-separator td {
      padding-top: 12px;
    }
  </style>
</head>
<body>
  <h1>MIDI Monitor</h1>
  <div id="status">
    <span class="label">Status: </span>
    <span id="connectionStatus" class="disconnected">Connecting...</span>
    <span style="margin-left: 20px;" class="label">Device: </span>
    <span id="deviceName" class="value">-</span>
    <span style="margin-left: 20px;" class="label">Channel: </span>
    <span id="channelDisplay" class="value">-</span>
  </div>
  <div id="log">
    <table>
      <thead>
        <tr>
          <th class="col-type">Type</th>
          <th class="col-channel">Ch</th>
          <th class="col-note">Note</th>
          <th class="col-name">Name</th>
          <th class="col-value">Value</th>
          <th class="col-drum">Drum</th>
          <th class="col-raw">Raw</th>
        </tr>
      </thead>
      <tbody id="logBody">
      </tbody>
    </table>
  </div>

  <script>
    // Drum note lookup table
    const drumMap = {
      // Snare (normal)
      38: 'Snare Head',
      40: 'Snare Rim',
      23: 'Snare Brush',
      37: 'Snare XStick',
      // Snare (wires off)
      19: 'Snare Head (wires off)',
      18: 'Snare Rim (wires off)',
      16: 'Snare Brush (wires off)',
      17: 'Snare XStick (wires off)',
      // Wire lever
      20: 'Wires Off',
      21: 'Wires On',
    };

    // CC name lookup
    const ccMap = {
      16: 'Radius',
      80: 'Angle',
      88: 'Fine Velocity',
    };

    // Note name conversion
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    function midiNoteToName(note) {
      const octave = Math.floor(note / 12) - 1;
      const name = noteNames[note % 12];
      return `${name}${octave}`;
    }

    // State
    let lastMessageTime = 0;
    const BURST_TIMEOUT_MS = 1000;
    let detectedChannel = null;
    let isNewBurst = true;

    const logBody = document.getElementById('logBody');
    const connectionStatus = document.getElementById('connectionStatus');
    const deviceNameEl = document.getElementById('deviceName');
    const channelDisplay = document.getElementById('channelDisplay');

    function formatRaw(data) {
      return Array.from(data).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
    }

    function addLogEntry(type, channel, note, name, value, drum, raw, cssClass) {
      const now = performance.now();
      const timeSinceLastMsg = now - lastMessageTime;
      
      // Check for burst timeout - if > 1 second since last message, clear log
      if (lastMessageTime > 0 && timeSinceLastMsg > BURST_TIMEOUT_MS) {
        logBody.innerHTML = '';
        isNewBurst = true;
      }
      
      lastMessageTime = now;

      const tr = document.createElement('tr');
      tr.className = cssClass;
      
      // Add separator styling for new bursts (except first entry)
      if (isNewBurst && logBody.children.length > 0) {
        tr.classList.add('burst-separator');
      }
      isNewBurst = false;

      tr.innerHTML = `
        <td class="col-type">${type}</td>
        <td class="col-channel">${channel}</td>
        <td class="col-note">${note}</td>
        <td class="col-name">${name}</td>
        <td class="col-value">${value}</td>
        <td class="col-drum">${drum}</td>
        <td class="col-raw">${raw}</td>
      `;
      
      logBody.appendChild(tr);
      
      // Auto-scroll to bottom
      const logDiv = document.getElementById('log');
      logDiv.scrollTop = logDiv.scrollHeight;

      // Update detected channel display
      if (channel !== '-' && detectedChannel !== channel) {
        detectedChannel = channel;
        channelDisplay.textContent = channel;
      }
    }

    function handleMIDIMessage(event) {
      const data = event.data || [];
      if (data.length < 1) return;

      const status = data[0];
      const cmd = status & 0xf0;
      const channel = (status & 0x0f) + 1;
      const data1 = data[1];
      const data2 = data[2];
      const raw = formatRaw(data);

      if (cmd === 0x90 && data2 > 0) {
        // Note On
        const noteName = midiNoteToName(data1);
        const drumName = drumMap[data1] || '';
        addLogEntry('Note On', channel, data1, noteName, data2, drumName, raw, 'note-on');
      } else if (cmd === 0x90 && data2 === 0 || cmd === 0x80) {
        // Note Off
        const noteName = midiNoteToName(data1);
        const drumName = drumMap[data1] || '';
        addLogEntry('Note Off', channel, data1, noteName, data2, drumName, raw, 'note-off');
      } else if (cmd === 0xb0) {
        // CC
        const ccName = ccMap[data1] || `CC ${data1}`;
        addLogEntry('CC', channel, data1, ccName, data2, '', raw, 'cc');
      } else if (cmd === 0xe0) {
        // Pitch Bend
        const bendValue = ((data2 << 7) | data1) - 8192;
        addLogEntry('Pitch Bend', channel, '-', '', bendValue, '', raw, 'other');
      } else if (cmd === 0xc0) {
        // Program Change
        addLogEntry('Program', channel, data1, '', '-', '', raw, 'other');
      } else if (cmd === 0xd0) {
        // Channel Pressure
        addLogEntry('Pressure', channel, '-', '', data1, '', raw, 'other');
      } else if (cmd === 0xa0) {
        // Polyphonic Aftertouch
        const noteName = midiNoteToName(data1);
        addLogEntry('Poly AT', channel, data1, noteName, data2, '', raw, 'other');
      } else if (status === 0xf8) {
        // Timing clock - ignore (too spammy)
      } else if (status === 0xfe) {
        // Active sensing - ignore (too spammy)
      } else {
        // Other/unknown
        addLogEntry('Other', '-', '-', '', '-', '', raw, 'other');
      }
    }

    async function initializeMIDI() {
      try {
        if (!navigator.requestMIDIAccess) {
          connectionStatus.textContent = 'Web MIDI not supported';
          connectionStatus.className = 'disconnected';
          return;
        }

        const midiAccess = await navigator.requestMIDIAccess({ sysex: true });
        const inputs = Array.from(midiAccess.inputs.values());

        if (inputs.length === 0) {
          connectionStatus.textContent = 'No MIDI devices found';
          connectionStatus.className = 'disconnected';
          return;
        }

        // Connect to first input
        const input = inputs[0];
        input.onmidimessage = handleMIDIMessage;

        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'connected';
        deviceNameEl.textContent = input.name || 'Unknown Device';

        console.log('MIDI Monitor connected to:', input.name);

        // Listen for device changes
        midiAccess.onstatechange = (e) => {
          console.log('MIDI device state changed:', e.port.name, e.port.state);
          if (e.port.state === 'disconnected' && e.port.id === input.id) {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'disconnected';
          }
        };

      } catch (error) {
        connectionStatus.textContent = 'MIDI access denied';
        connectionStatus.className = 'disconnected';
        console.error('MIDI error:', error);
      }
    }

    // Start immediately
    initializeMIDI();
  </script>
</body>
</html>

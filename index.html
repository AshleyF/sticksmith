<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>MIDI Beats</title>
        <style>
            body { font-family: sans-serif; text-align: center; padding-top: 30px; }
            canvas { border: 1px solid #ddd; margin-top: 20px; }
        </style>
    </head>
    <body>
        <h1>MIDI Beats</h1>
        <canvas id="timeSeriesCanvas" width="800" height="100"></canvas><br />
        <div>
            <button id="midiBtn">Enable MIDI</button>
            <span id="debug"></span>
        </div>
        <script>
const timeSeriesCanvas = document.getElementById('timeSeriesCanvas');
const timeCtx = timeSeriesCanvas.getContext('2d');
const canvasTimeSpan = 5; // Time span in seconds that the canvas represents
const pixelsPerMs = timeSeriesCanvas.width / (canvasTimeSpan * 1000); // Pixels per millisecond
const bpm = 60;
const flamThreshold = 100; // TODO: relative to BPM? Time in milliseconds for close succession
const resetAfterSilenceTimeSpan = 3; // Time span in seconds after which we reset

let notes = []; // Array to store MIDI velocities and timestamps

let lastNoteTime = performance.now();
function record(instrument, velocity, time) {
    // TODO: instruments
    const elapsed = time - lastNoteTime;
    notes.push({ velocity, elapsed });
    lastNoteTime = time;
}

function transcribe(notes) {
    function quantize(time) {
        const whole = 1000 * 60 / bpm;
        if (time > whole * 0.75) {
            return "whole";
        } else if (time > (whole / 2) * 0.75) {
            return "half";
        } else if (time > (whole / 4) * 0.75) {
            return "quarter";
        } else if (time > (whole / 8) * 0.75) {
            return "eighth";
        } else if (time > (whole / 16) * 0.75) {
            return "sixteenth";
        } else {
            return "thirty-second";
        }
    }
    if (notes.length < 2) {
        return "?";
    }
    return quantize(notes[notes.length - 1].elapsed);
    // TODO: assume single note is whole (or remainder of measure)
    //for (let i = 0; i < notes.length - 1; i++) {
    //    const n = notes[i];
    //    const next = notes[i + 1];
    //    const time = next.elapsed;

    //    // if (next.elapsed - n.elapsed < flamThreshold) {
    //    //     // If the next note is within the flam threshold, adjust the velocity
    //    //     n.velocity = Math.max(n.velocity, next.velocity);
    //    //     notes.splice(i + 1, 1); // Remove the next note
    //    //     i--; // Adjust index after removal
    //    // }
    //}
}

function display() {
    timeCtx.clearRect(0, 0, timeSeriesCanvas.width, timeSeriesCanvas.height);
    const now = performance.now();
    let accumulatedTime = now - lastNoteTime;
    if (accumulatedTime > resetAfterSilenceTimeSpan * 1000) {
        notes = []; // start over once too old
    }
    document.getElementById('debug').innerText = `Notes: ${notes.length} (${transcribe(notes)})`;
    for (let i = notes.length - 1; i >= 0; i--) {
        const n = notes[i];
        const x = timeSeriesCanvas.width - accumulatedTime * pixelsPerMs; // Calculate x-coordinate
        accumulatedTime += n.elapsed; // Accumulate elapsed time
        if (x < 0) break; // off left
        //let height = Math.pow(n.velocity / 127, 2) * timeSeriesCanvas.height; // Apply power curve scaling
        let height = n.velocity / 127 * timeSeriesCanvas.height;
        let color = n.elapsed < flamThreshold ? 'blue' : 'red';
        timeCtx.beginPath();
        timeCtx.moveTo(x, timeSeriesCanvas.height);
        timeCtx.lineTo(x, timeSeriesCanvas.height - height);
        timeCtx.strokeStyle = color;
        timeCtx.stroke();
    }
    requestAnimationFrame(display); // Continue the animation loop
}

let midiInputs = []; // Store references to MIDI inputs

async function initializeMIDI() {
    try {
        if (!navigator.requestMIDIAccess) {
            throw 'Web MIDI API is not supported in this browser.';
        }
        const midiAccess = await navigator.requestMIDIAccess();
        midiInputs = Array.from(midiAccess.inputs.values()); // Store all MIDI inputs
        midiInputs.forEach((input) => {
            input.onmidimessage = handleMIDIMessage; // Listen for MIDI messages
        });
        console.log('MIDI initialized. Listening for input...');
    } catch (error) {
        alert('Failed to access MIDI devices:', error);
    }
}

function disableMIDI() {
    midiInputs.forEach((input) => {
        input.onmidimessage = null; // Stop listening for MIDI messages
    });
    console.log('MIDI disabled. Inputs released.');
}

function handleMIDIMessage(message) {
    const [status, note, velocity] = message.data;
    // console.log(`MIDI Message: Status: ${status}, Note: ${note}, Velocity: ${velocity}`);
    if (status === 153 && note === 60 && velocity > 0) { // "note on" event (status 0x90) and the note is 60
        // TODO: instruments
        record('snare', velocity, performance.now());
    }
}

let midiEnabled = false;
document.getElementById('midiBtn').onclick = async () => {
    if (midiEnabled) {
        disableMIDI();
    } else {
        await initializeMIDI();
    }
    document.getElementById('midiBtn').innerText = midiEnabled ? 'Disable MIDI' : 'Enable MIDI';
    midiEnabled = !midiEnabled;
};

document.addEventListener('keydown', (event) => {
    switch (event.code) {
        case 'KeyD':
            record('snare', 80, performance.now());
            break;
        case 'KeyS':
            record('snare', 40, performance.now());
            break;
        case 'KeyF':
            record('snare', 120, performance.now());
            break;
        case 'KeyK':
            record('snare', 80, performance.now());
            break;
        case 'KeyJ':
            record('snare', 120, performance.now());
            break;
        case 'KeyL':
            record('snare', 40, performance.now());
            break;
        case 'Space':
            record('kick', 80, performance.now());
            break;
        default: return;
    }
    event.preventDefault();
});

display();
        </script>
    </body>
</html>